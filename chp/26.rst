第26章 高级库设计：构建一个布隆过滤器
==========================================

布隆过滤器介绍
----------------

布隆过滤器（Bloom Filter）是类似集合的一种数据结构，它的特点是高效率的空间利用。布隆过滤器只支持两种操作：插入和成员查询。与常规的集合数据结构不同，布隆过滤器可能会给出不正确的结果。如果我们查询之前插入的一个元素是否存在，布隆过滤器会返回肯定的结果。但是如果我们查询一个之前未插入的元素，布隆过滤器可能会声称它是存在的。

对大多数应用来说，低概率的误判是可以容忍的。举个例子，网络流量整形（traffic shaper）的主要工作是限制批量传输（比如BitTorrent），使得一些交互式会话（比如\ **ssh**\ 或者游戏）可以得到优秀的响应时间。流量整形可能会使用布隆过滤器来判断一个特定会话的数据包是批量的还是交互的。如果布隆过滤器在10000个批量数据包中误判其中1个是交互式的并且没有截止，也不会造成任何问题。

布隆过滤器吸引人的地方在于它的空间效率。如果我们想要构建一个拼写检查器，我们有一个包含一百万个单词的词典，使用集合数据结构的话可能会消耗20MB的空间。相比之下，布隆过滤器会消耗大约0.5MB，代价是漏掉大约1%拼错的单词。

布隆过滤器的内部非常简单。它由一个位数组和少数哈希函数组成。我们使用k表示哈希函数的数量。如果我们想要往布隆过滤器中插入数据，我们使用哈希函数为数据计算出 **k** 个哈希值，然后在位数组中把这些位打开（设置为1）。如果我们想要看看某个数据是否存在，那么就计算出 *k* 个哈希值，然后检查位数组中这些哈希值的位是否都被打开。

为了理解整个过程，让我们举个例子，比如说我们想要往布隆过滤器中插入字符串 ``“foo”`` 和 ``“bar”``，这个布隆过滤器有8位宽，并且我们有两个哈希函数。

1. 计算 ``“foo”`` 的两个哈希，得到 ``1`` 和 ``6``
2. 在位数组中置位 ``1`` 和 ``6``
3. 计算 ``“bar”`` 的两个哈希，得到 ``6`` 和 ``3``
4. 在位数组中置位 ``6`` 和 ``3``

这个例子清晰地解释了为什么我们不能从布隆过滤器中移除一个元素：插入 ``“foo”`` 和 ``“bar”`` 都会导致位 ``6`` 被置位。

假设我们现在想要查询布隆过滤器中 ``“quux”`` 和 ``“baz“`` 是否存在

1. 计算 ``“quux”`` 的两个哈希，得到 ``4`` 和 ``0``
2. 检查位数组中的位 ``4``，位 ``4`` 没有被置位，所以 ``“quux”`` 不可能存在，我们不需要检查位 ``0``
3. 计算 ``“baz”`` 的两个哈希，得到 ``1`` 和 ``3``
4. 检查位数组中的位 ``1`` ，位 ``1`` 被置位，同样的位 ``3`` 也被置位，所以我们得到 ``“baz”`` 存在的结果，但是实际上不存在。这里我们得到了一个误判。

如果你想要查看布隆过滤器的一些使用案例的调查，请参阅 [Broder02]_

使用场景与封装设计
------------------

不是所有布隆过滤器的使用都有相同的需求。在某些使用场景中，只需要一次性创建布隆过滤器，之后只有查询。对其他应用，我们可能需要在创建布隆过滤器之后持续更新。为了适应这些需求，我们将使用可变与不可变的API来设计我们的库。

我们将可变与不可变的API分离，通过把他们放在不同的模块中： ``BloomFilter`` 用于不可变的代码，``BloomFilter.Mutable`` 用于可变代码。

另外，我们将创建一些辅助模块，这些模块不会在公开的API中出现，但它们可以让内部代码变得更清晰。

最后，我们让API的使用者提供用来产生多个哈希的函数。这个函数的类型是 ``a -> [Word32]`` 。我们将使用这个函数返回的全部哈希值，所以这个函数返回的列表不能为无穷的。

基本设计
------------------

我们为Haskell的布隆过滤器使用的数据结构是之前我们给出的简单介绍中的直接翻译：一个位数组和一个计算多个哈希值的函数

::

    -- file: BloomFilter/Internal.hs
    module BloomFilter.Internal
        (
          Bloom(..)
        , MutBloom(..)
        ) where

    import Data.Array.ST (STUArray)
    import Data.Array.Unboxed (UArray)
    import Data.Word (Word32)

    data Bloom a = B {
          blmHash  :: (a -> [Word32])
        , blmArray :: UArray Word32 Bool
        }

当我们创建我们的Cabal包时，我们不会导出这个 ``BloomFilter.Internal`` 模块。这个模块的存在纯粹是为了让我们控制名称的可见性。我们把 ``BloomFilter.Internal`` 导入可变和不可变的模块中，但是我们会从各个模块中重新导出和模块API相关的类型。

拆箱，提升和bottom
^^^^^^^^^^^^^^^^^^^^^^^^

与其他Haskell的数组不同， ``UArray`` 包含未装箱的值。

对于一个常规的Haskell类型来说，它的值既可以是完全求值的（full evaluated），也可以是未求值的形式程序（thunk），又或者特殊值⊥，发音（有时候也写作）为"bottom"。值 ``⊥`` 是一个用来表示计算未成功的占位符。这里的计算可以有多种形式。它可能是一个无限循环，一个 ``error`` 应用，或者特殊值 ``undefined`` 。

一个可以包含bottom的类型被称为已提升的。所有常规Haskell类型都是已提升的。实际中，这意味着我们可以写 ``error "eek!"`` 或者 ``undefined`` 来代替常规表达式。

存储形式程序和bottom的能力会带来性能上的损耗：这种能力增加了额外的间接层。为了理解为什么我们需要这种间接，考虑 ``Word32`` 类型。这是类型的值是全32位宽的，所以在32位系统上，没有办法直接用32位来编码bottom。运行时系统不得不维护，并且检查一些额外的数据来跟踪这个值是不是 ``⊥`` 。

一个未装箱的值没有这种间接性。通过未装箱，获得了性能，但是牺牲了表示形式程序或者bottom的能力。因为未装箱的数组可以比常规Haskell的数组更加紧凑，所以这对于大量数据和位来说是一个非常好的选择。

  装箱和提升

  对应未装箱的类型的是使用了间接层的装箱类型。所有提升的值都是装箱的，但是一些底层的装箱类型没有被提升。比如，GHC的运行时系统有一个底层数组类型用于装箱（比如，它维护了一个数组的指针）。如果它是一个数组的引用，那么它知道数组肯定是存在的，所以它不需要关心bottom是否存在。所以这个数组类型是装箱的，但是未提升的。装箱但是未提升的类型仅展示了底层运行时的特殊实现（hacking）。在常规使用中我们不会遇到它们。

GHC实现了一个 ``Bool`` 类型的 ``UArray`` ，内部把8个数组元素组装为1个byte，所以这个类型非常适合我们的需求。

ST monad
---------------------------

.. TODO back to chapter 12 "修改数组元素"

回到“修改数组元素”的部分，我们提到修改一个不可变的数组代价很高，因为这需要复制整个数组。即使使用 ``UArray`` ，这一问题仍然会存在，所以我们如何才能将复制不可变数组的代价降低到我们可以承受的水平呢？

在指令式语言中，我们可以简单地原地修改数组元素；我们也可以在Haskell中这么做。

Haskell提供了一个特殊的Monad，叫做 ``ST``  *（State Transformer）* 。 ``ST`` 允许我们安全地工作在可变的状态下。与 ``State`` Monad相比，它有一些强大的额外的功能。

* 我们可以解冻一个不可变数组得到一个可变数组；就地修改可变数组；和在完成时冻结出一个新的可变数组
* 我们可以使用 *可变引用 (mutable references)* 。这允许我们在构建数据结构之后修改它，就像在命令式语言中的一样。这个功能对于一些命令式数据结构和算法很重要，因为尚未找到类似的高效纯函数替代。

``IO`` Monad同样提供了这些功能。两者的主要区别是 ``ST`` Monad是有意设计用来退回到纯Haskell代码的。我们通过执行函数 ``runST`` 进入 ``ST`` Monad，就像大部分其他Haskell Monad（当然除了 ``IO`` ）一样，然后通过从 ``runST`` 中return来退出。

当我们应用一个Monad的执行函数的时候，我们希望它可以反复运行：如果给予相同的函数体（body）和参数，我们每次都能得到相同的结果。这同样可以应用于 ``runST`` 。为了达到这种可重复性（repeatablility），``ST`` monad比 ``IO`` monad更加严格。我们不能读写文件，创建全局变量，或者创建线程。甚至，即使我们可以创建并且使用可变的引用和数组，类型系统也不允许它们逃逸到 ``runST`` 的调用方。在我们能够返回数据之前，一个可变的数组必须被冻结（frozen）为一个不可变的数组，并且一个可变的引用完全不可以逃逸。

设计一个合格的导入API
------------------------

我们需要讨论一下用来处理布隆过滤器的公开接口。

::

  -- file: BloomFilter/Mutable.hs
  module BloomFilter.Mutable
      (
        MutBloom
      , elem
      , notElem
      , insert
      , length
      , new
      ) where

  import Control.Monad (liftM)
  import Control.Monad.ST (ST)
  import Data.Array.MArray (getBounds, newArray, readArray, writeArray)
  import Data.Word (Word32)
  import Prelude hiding (elem, length, notElem)

  import BloomFilter.Internal (MutBloom(..))

我们导出的一些API的名字与Prelude中导出的名字冲突。这是值得商榷的：我们希望模块的用户用全名来导入API。这会减少用户的记忆负担，因为他们应该已经熟悉了Prelude的 ``elem`` , ``notElem`` 和 ``length`` 函数。

当我们使用这种风格的模块时，我们可能经常用单个字母前缀来导入它。比如 ``import qualified BloomFilter.Mutable as M`` ，这允许我们写 ``M.length`` 这样的紧凑、可读的代码。

另一种方法是，我们可以不用全名导入模块，并且在导入Prelude时隐藏冲突的API。比如 ``import Prelude hiding (length)`` 。这种方法有时候不是那么好，因为它没有给阅读代码的人暗示他们看到的不是Prelude的 ``length`` 。

当然，我们看起来违反了我们自己的模块头的声明：我们导入了Prelude，并且隐藏了它导出的一些API名字。这是有实际原因的。我们定义了一个叫做 ``length`` 的函数。当我们在不先隐藏Prelude的 ``length`` 的情况下导出我们模块的length的话，编译器会出错。因为他不知道该导出我们定义的 ``length`` 还是Prelude的那个。

虽然有点不太好看，我们也可以导出全名 ``BloomFilter.Mutable.length`` 来消除二义性。当然最终的决定不会对我们模块的用户有影响，只是作为作者，希望把模块设计成黑盒子，所以在这里不用太迷惑。

创建一个可变的布隆过滤器
------------------------

我们把可变的布隆过滤器的类型定义放在 ``BloomFilter.Internel`` 模块中，与不可变的 ``Bloom`` 类型一起。

::

  -- file: BloomFilter/Internal.hs
  data MutBloom s a = MB {
        mutHash :: (a -> [Word32])
      , mutArray :: STUArray s Word32 Bool
      }

``STUArray`` 类型在这里是一个可变的未装箱数组，可以 ``ST`` 来处理。为了创建一个 ``STUArray`` ，我们使用 ``newArray`` 函数。 ``new`` 函数属于 ``BloomFilter.Mutable`` 。

::

  -- file: BloomFilter/Mutable.hs
  new :: (a -> [Word32]) -> Word32 -> ST s (MutBloom s a)
  new hash numBits = MB hash `liftM` newArray (0,numBits-1) False

``STUArray`` 的大部分方法实际由 ``MArray`` 实现，``MArray`` 定义在 ``Data.Array.MArray`` 模块中。

我们的 ``length`` 函数在两点上有一点复杂。我们依赖位数组的范围记录，并且 ``MArray`` 实例的 ``getBounds`` 函数有一个独特（？，monadic）类型。同时我们必须在结果上加1，因为数组的上限比它的长度少1。

::

  -- file: BloomFilter/Mutable.hs
  length :: MutBloom s a -> ST s Word32
  length filt = (succ . snd) `liftM` getBounds (mutArray filt)

为了往布隆过滤器添加元素，我们按照哈希函数设置所有位。我们使用 ``mod`` 函数保证所有哈希值都在我们的数组范围内，并且把计算位数组偏移的代码隔离到另外一个函数中。

::

  -- file: BloomFilter/Mutable.hs
  insert :: MutBloom s a -> a -> ST s ()
  insert filt elt = indices filt elt >>=
                    mapM_ (\bit -> writeArray (mutArray filt) bit True)

  indices :: MutBloom s a -> a -> ST s [Word32]
  indices filt elt = do
    modulus <- length filt
    return $ map (`mod` modulus) (mutHash filt elt)

测试是否是成员并不复杂，如果哈希函数计算出来的所有位都打开，我们就认为这个元素在布隆过滤器中。

::

  -- file: BloomFilter/Mutable.hs
  elem, notElem :: a -> MutBloom s a -> ST s Bool

  elem elt filt = indices filt elt >>=
                  allM (readArray (mutArray filt))

  notElem elt filt = not `liftM` elem elt filt

我们需要一个辅助函数： ``all`` 的monadic版本，叫做 ``allM`` 。

::

  -- file: BloomFilter/Mutable.hs
  allM :: Monad m => (a -> m Bool) -> [a] -> m Bool
  allM p (x:xs) = do
    ok <- p x
    if ok
      then allM p xs
      else return False
  allM _ [] = return True


不可变API
------------------------

我们的不可变布隆过滤器的接口与可变布隆过滤器有相同的结构。

::

  -- file: ch26/BloomFilter.hs
  module BloomFilter
      (
        Bloom
      , length
      , elem
      , notElem
      , fromList
      ) where

  import BloomFilter.Internal
  import BloomFilter.Mutable (insert, new)
  import Data.Array.ST (runSTUArray)
  import Data.Array.IArray ((!), bounds)
  import Data.Word (Word32)
  import Prelude hiding (elem, length, notElem)

  length :: Bloom a -> Int
  length = fromIntegral . len

  len :: Bloom a -> Word32
  len = succ . snd . bounds . blmArray

  elem :: a -> Bloom a -> Bool
  elt `elem` filt   = all test (blmHash filt elt)
    where test hash = blmArray filt ! (hash `mod` len filt)

  notElem :: a -> Bloom a -> Bool
  elt `notElem` filt = not (elt `elem` filt)

我们提供了一个易于使用的方法来创建不可变布隆过滤器，``fromList`` 函数。
这个函数对用户隐藏了 ``ST`` monad，因此用户只能看到不可变类型。

::

  -- file: ch26/BloomFilter.hs
  fromList :: (a -> [Word32])    -- family of hash functions to use
           -> Word32             -- number of bits in filter
           -> [a]                -- values to populate with
           -> Bloom a
  fromList hash numBits values =
      B hash . runSTUArray $
        do mb <- new hash numBits
           mapM_ (insert mb) values
           return (mutArray mb)

这个函数的关键是 ``runSTUArray`` 。我们早先提到为了从 ``ST`` monad中返回一个不可变的数组，我们必须冻结（freeze）一个可变的数组。 ``runSTUArray`` 函数组合了执行和冻结。给定一个返回一个 ``STUArray`` 的操作， ``runST`` 将执行这个操作，冻结操作返回的 ``STUArray`` ，并作为一个 ``UArray`` 返回给用户。

我们也可以使用 ``MArray`` 类型提供了的 ``freeze`` 函数，但是 ``runSTUArray`` 更加方便和高效。 后者的效率基于以下事实， ``freeze`` 函数必须从 ``STUArray`` 复制底层数据到新的 ``UArray``，为了保证对 ``STUArray`` 的后续修改不会影响到 ``UArray`` 的内容。感谢类型系统， ``runSTUArray`` 可以保证当 ``STUArray`` 被用于创建一个 ``UArray`` 时他将不能继续被访问。因此可以在两个数组（ ``STUArray`` 和 ``UArray`` ）之间共享底层数据，避免了复制。

创建一个友好的接口
------------------------

虽然我们的不可变布隆过滤器可以在创建之后直接使用， ``fromList`` 仍然留下了一些重要问题未解决。我们仍然必须选择一个函数来生成很多哈希值，和决定布隆过滤器的空间大小应该是多少。

::

  -- file: BloomFilter/Easy.hs
  easyList :: (Hashable a)
           => Double        -- false positive rate (between 0 and 1)
           -> [a]           -- values to populate the filter with
           -> Either String (B.Bloom a)

这里有一个可能的“更加友好”的方式来创建布隆过滤器。它将计算哈希值的职责留给了类型 ``Hashable``。这允许我们用一个易于理解的参数来配置布隆过滤器，也就是我们愿意容忍的误报率。并且这将帮助我们基于期望的误报率和输入列表中的元素数量来选择过滤器的大小。

当然这个函数不会一直有用：比如，在输入列表过长的时候它将失败。不管怎样，它的简易性实现了我们提供的其他接口。这让我们给用户提供了超过直接创建的控制能力，从完全命令式到完全声明式。

为了方便重新导出名称

在我们模块的到处列表中，我们重新从基础的 ``BloomFilter`` 模块导出了一些名称。这允许那些随便的用户仅导入 ``BloomFilter.Easy`` 模块，并可以访问他们可能需要的所有类型和函数。

如果我们同时导入 ``BloomFilter.Easy`` 和 ``BloomFilter`` ，你可能想知道如果我们尝试使用一个被两者同时导出的名称会发生什么。我们已经知道如果我们没有使用全名来导入 ``BloomFilter`` 并且尝试使用 ``length`` ，GHC将报“不明确”错误，这是因为 ``Prelude`` 中也有 ``length`` 。

Haskell标准中需要一个能够在引用相同“东西”的时候区分的实现。比如， ``Bloom`` 类型被 ``BloomFilter`` 和 ``BloomFilter.Easy`` 导出。如果我们同时导入两个模块并且尝试使用 ``Bloom`` ，GHC能识别出被 ``BloomFilter.Easy`` 重新导出的 ``Bloom`` 和从 ``BloomFilter`` 中导出的是同一个，所以会被报告“不明确”错误。

哈希值

布隆过滤器为了高性能和低误判率依赖快速，高质量的哈希函数。一般很难写出同时满足这些特性的通用哈希函数。

我们很幸运，一个叫做Bob Jenkins的人开发了一些着实有这些特性的函数，并且把他的代码放在了公开域名上， http://burtleburtle.net/bob/hash/doobs.html [59]_ 。他用C写了这些哈希函数，所以我们可以简单地通过FFI创建绑定。从那个网站上我们需要的特定源码文件叫做 ``lookup3.c`` [LOOKUP3_C]_ 。我们创建 ``cbits`` 目录并把文件下载到那里。



.. [Broder02] Andrei Broder. Michael Mitzenmacher. “Network applications of Bloom filters: a survey”. Internet Mathematics. 1. 4. 2005. 485-509. A K Peters Ltd..

.. [59] Jenkins写的哈希函数有更好的混合特性，相对其他流行的非加密哈希函数，比如FNV和 ``hashpjw`` ，所以我们推荐不要用他们。

.. [LOOKUP3_C] http://burtleburtle.net/bob/c/lookup3.c